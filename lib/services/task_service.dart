import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:producthive/models/task_model.dart'; // Adjust with your actual path
import 'package:producthive/database/database_helper.dart'; // Adjust with your actual path

class TaskService {
  final DatabaseHelper _databaseHelper = DatabaseHelper.instance;
  final String apiUrl = 'https://api.nstack.in/v1/todos';

  
  // Future<void> fetchAndStoreTasks() async {
  //   try {
  //     // await _databaseHelper.deleteAllTasks();
  //     final response = await http.get(Uri.parse(apiUrl));

  //     if (response.statusCode == 200) {
  //       final Map<String, dynamic> jsonResponse = json.decode(response.body);
  //       final List<dynamic> items = jsonResponse['items'];

  //       // Print fetched tasks
  //       for (var item in items) {
  //         print('Fetched Todo: ${item['title']}, '
  //             'Description: ${item['description']}, '
  //             'Completed: ${item['is_completed']}, '
  //             'Created At: ${item['created_at']}');
  //       }

  //       // Store tasks in the database
  //       for (var item in items) {
  //         Task task = Task(
  //           id: null, // ID auto-generated by local DB
  //           name: item['title'],
  //           completed: item['is_completed'],
  //           date: DateTime.parse(item['created_at']),
  //           description: item['description'],
  //           apiId: item['_id'],
  //         );
  //         await _databaseHelper.addTask(task);
  //       }
  //       print('All tasks stored in the database.');
  //     } else {
  //       print('Failed to load tasks: ${response.statusCode}');
  //     }
  //   } catch (e) {
  //     print('Error fetching tasks: $e');
  //   }
  // }

  // Method to fetch tasks from the API and store them in the DB
  Future<void> fetchAndStoreTasks() async {
    try {
      // Retrieve tasks from the API
      final response = await http.get(Uri.parse(apiUrl));
      if (response.statusCode != 200) {
        print('Failed to load tasks from API: ${response.statusCode}');
        return;
      }

      final Map<String, dynamic> jsonResponse = json.decode(response.body);
      final List<dynamic> items = jsonResponse['items'];

      // Retrieve all existing tasks from the local database
      List<Task> existingTasks = await _databaseHelper.getTasks();
      Map<String, Task> existingTaskMap = {
        for (var task in existingTasks)
          if (task.apiId != null) task.apiId!: task
      };

      // Track API task IDs for deletion check
      Set<String> apiTaskIds =
          items.map((item) => item['_id'] as String).toSet();

      // Synchronize tasks from API to local database
      await _syncTasksWithAPI(items, existingTaskMap);

      // Delete local tasks that no longer exist in the API
      await _deleteMissingTasksFromDB(existingTasks, apiTaskIds);

      print('Tasks have been synchronized successfully.');
    } catch (e) {
      print('Error fetching tasks: $e');
    }
  }

  Future<void> _syncTasksWithAPI(
      List<dynamic> items, Map<String, Task> existingTaskMap) async {
    for (var item in items) {
      String? apiId = item['_id'];
      if (apiId == null) {
        print('Skipping task with null API ID.');
        continue;
      }

      Task task = Task(
        name: item['title'] ?? '',
        completed: item['is_completed'] ?? false,
        date: DateTime.parse(item['created_at']),
        description: item['description'] ?? '',
        apiId: apiId,
      );

      if (existingTaskMap.containsKey(apiId)) {
        await _updateTaskIfChanged(task, existingTaskMap[apiId]!);
      } else {
        await _addNewTask(task);
      }
    }
  }

  Future<void> _updateTaskIfChanged(Task newTask, Task existingTask) async {
    // Check if any field is different before updating
    if (existingTask.name != newTask.name ||
        existingTask.completed != newTask.completed ||
        existingTask.date != newTask.date ||
        existingTask.description != newTask.description) {
      // Preserve local ID for updating
      newTask.id = existingTask.id;
      await _databaseHelper.updateTask(newTask);
      print('Updated task: ${newTask.name}');
    }
  }

  Future<void> _addNewTask(Task task) async {
    await _databaseHelper.addTask(task);
    print('Added new task: ${task.name}');
  }

  Future<void> _deleteMissingTasksFromDB(List<Task> existingTasks, Set<String> apiTaskIds) async {
    for (var existingTask in existingTasks) {
      if (existingTask.apiId != null &&
          !apiTaskIds.contains(existingTask.apiId!)) {
        await _databaseHelper.deleteTask(existingTask.apiId!);
        print('Deleted task no longer in API: ${existingTask.name}');
      }
    }
  }

  // POST request to add a new task to the API
  Future<void> addTaskToAPI(Task task) async {
    try {
      final response = await http.post(
        Uri.parse(apiUrl),
        headers: {'Content-Type': 'application/json'},
        body: json.encode({
          "title": task.name,
          "description": task.description ?? "",
          "is_completed": task.completed,
        }),
      );

      if (response.statusCode == 201) {
        print('Task added successfully: ${response.body}');
      } else {
        print('Failed to add task: ${response.body}');
      }
    } catch (e) {
      print('Error adding task: $e');
    }
  }

  // Delete task from API and database
  Future<void> deleteTaskFromAPI(String apiId) async {
    final url = '$apiUrl/$apiId';

    try {
      final response = await http.delete(Uri.parse(url));

      if (response.statusCode == 200) {
        print('Task deleted from API successfully');
        // Delete task from the local database using API ID
        await _databaseHelper.deleteTask(apiId);
      } else {
        print('Failed to delete task from API: ${response.body}');
        throw Exception('Failed to delete task from API');
      }
    } catch (e) {
      print('Error deleting task from API: $e');
      throw e;
    }
  }

  //update task in API and then in local database
  Future<void> updateTaskInAPI(Task task) async {
    final url = '$apiUrl/${task.apiId}';

    try {
      final response = await http.put(
        Uri.parse(url),
        headers: {'Content-Type': 'application/json'},
        body: json.encode({
          "title": task.name,
          "description": task.description ?? "",
          "is_completed": task.completed,
        }),
      );

      if (response.statusCode == 200) {
        print('Task updated in API successfully');
      } else {
        print('Failed to update task in API: ${response.body}');
        throw Exception('Failed to update task in API');
      }
    } catch (e) {
      print('Error updating task in API: $e');
      throw e;
    }
  }

  //delete all tasks from the API
  Future<void> deleteAllTasksFromAPI() async {
    try {
      final response = await http.get(Uri.parse(apiUrl));

      if (response.statusCode == 200) {
        final Map<String, dynamic> jsonResponse = json.decode(response.body);
        final List<dynamic> items = jsonResponse['items'];

        for (var item in items) {
          final apiId = item['_id'];
          final deleteUrl = '$apiUrl/$apiId';

          final deleteResponse = await http.delete(Uri.parse(deleteUrl));

          if (deleteResponse.statusCode == 200) {
            print('Task with ID $apiId deleted from API successfully');
            await _databaseHelper.deleteAllTasks();
          } else {
            print(
                'Failed to delete task with ID $apiId: ${deleteResponse.body}');
          }
        }
      } else {
        print('Failed to fetch tasks: ${response.statusCode}');
      }
    } catch (e) {
      print('Error deleting all tasks from API: $e');
    }
  }
}
